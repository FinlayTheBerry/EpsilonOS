#!/usr/bin/env python3
import subprocess
import os
import sys

# region EOS Script Helpers
def WriteFile(filePath, contents, binary=False):
    filePath = os.path.realpath(os.path.expanduser(filePath))
    os.makedirs(os.path.dirname(filePath), exist_ok=True)
    with open(filePath, "wb" if binary else "w", encoding=(None if binary else "UTF-8")) as file:
        file.write(contents)
def ReadFile(filePath, defaultContents=None, binary=False):
    filePath = os.path.realpath(os.path.expanduser(filePath))
    if not os.path.exists(filePath):
        if defaultContents != None:
            return defaultContents
    with open(filePath, "rb" if binary else "r", encoding=(None if binary else "UTF-8")) as file:
        return file.read()
def RunCommand(command, echo=False, capture=False, input=None, check=True, env=None):
    if echo and capture:
        raise Exception("Command cannot be run with both echo and capture.")
    result = subprocess.run(command, stdout=(None if echo else subprocess.PIPE), stderr=(None if echo else subprocess.STDOUT), input=input, env=env, check=False, shell=True, text=True)
    if check and result.returncode != 0:
        print(result.stdout)
        raise Exception(f"Sub-process returned non-zero exit code.\nExitCode: {result.returncode}\nCmdLine: {command}")
    if capture and not check:
        return result.stdout.strip(), result.returncode
    elif capture:
        return result.stdout.strip()
    elif not check:
        return result.returncode
    else:
        return
def PrintWarning(message):
    print(f"\033[93mWarning: {message}\033[0m")
def PrintError(message):
    print(f"\033[91mERROR: {message}\033[0m")
# endregion

def Main():
    script_path = os.path.realpath(__file__)
    script_name = os.path.splitext(os.path.basename(script_path))[0]
    install_path = f"/usr/bin/{script_name}"

    # Initial setup and scanity checks
    is_root = os.geteuid() == 0 and os.getegid() == 0
    if not is_root:
        PrintError(f"Root is required to run {script_name}. Try sudo {script_name}.")
        return 1
    if RunCommand("findmnt --noheadings --raw --output source --target /boot", check=False) != 0:
        PrintError("Nothing is mounted on /boot. Did you forget something?")
        return 1
    if RunCommand("findmnt --noheadings --raw --output source --target /sys/firmware/efi/efivars/", check=False) != 0:
        PrintError("Nothing is mounted on /sys/firmware/efi/efivars/. Did you forget something?")
        return 1
    kernel_paths = RunCommand("find /usr/lib/modules -maxdepth 2 -mindepth 2 -type f -name vmlinuz", capture=True).splitlines()
    if len(kernel_paths) == 0:
        PrintError("Unable to locate system kernel.")
        return 1
    if len(kernel_paths) > 1:
        PrintError("Multiple system kernels found.")
        return 1
    kernel_path = kernel_paths[0]
    root_dev = RunCommand("findmnt --noheadings --raw --output source --target /", capture=True)
    crypt_info, crypt_status_code = RunCommand(f"cryptsetup status \"{root_dev}\"", capture=True, check=False)
    if crypt_status_code != 0:
        PrintError(f"{script_name} requires an encrypted root partition.")
        return 1
    crypt_root_dev = crypt_info[crypt_info.find("device:") + len("device:"):crypt_info.find("\n", crypt_info.find("device:") + len("device:"))].strip()
    oprom_esl_path = "./oprom.esl"
    if not os.path.exists(oprom_esl_path):
        PrintError(f"OpROM signatures could not be found at \"{oprom_esl_path}\".")
        return 1
    secure_boot = ReadFile("/sys/firmware/efi/efivars/SecureBoot-8be4df61-93ca-11d2-aa0d-00e098032b8c", binary=True)[4:] == b"\x01"
    setup_mode = ReadFile("/sys/firmware/efi/efivars/SetupMode-8be4df61-93ca-11d2-aa0d-00e098032b8c", binary=True)[4:] == b"\x01"
    if not secure_boot and not setup_mode:
        PrintWarning(f"Secure boot is disabled. This feature is required to use {script_name}.")

    # Disable mkinitcpio hooks
    hooks_dir_path = "/usr/share/libalpm/hooks"
    for hook_name in os.listdir(hooks_dir_path):
        if "mkinitcpio" in hook_name and not hook_name.endswith(".disabled"):
            old_hook_path = os.path.join(hooks_dir_path, hook_name)
            new_hook_path = os.path.join(hooks_dir_path, hook_name + ".disabled")
            RunCommand(f"mv \"{old_hook_path}\" \"{new_hook_path}\"")

    # Install the boot builder pacman hook
    hook_payload = [
        f"# This file is auto-generated by {script_name}.",
        f"# Do not modify. All changes will be lost.",
        f"",
        f"[Trigger]",
        f"Operation = Install",
        f"Operation = Upgrade",
        f"Type = Package",
        f"Target = linux",
        f"",
        f"[Action]",
        f"Description = Running {script_name}...",
        f"When = PostTransaction",
        f"Exec = {install_path}",
    ]
    hook_path = os.path.join(hooks_dir_path, "boot_builder.hook")
    WriteFile(hook_path, "".join([ line + "\n" for line in hook_payload ]))
    RunCommand(f"chmod 644 \"{hook_path}\"")
    RunCommand(f"chown +0:+0 \"{hook_path}\"")

    # Create boot builder temp folder
    temp_dir_path = "/tmp/boot_builder"
    RunCommand(f"rm -rf \"{temp_dir_path}\"")
    RunCommand(f"mkdir \"{temp_dir_path}\"")
    RunCommand(f"chmod 700 \"{temp_dir_path}\"")
    RunCommand(f"chown +0:+0 \"{temp_dir_path}\"")

    # Generate initramfs
    print("Making initramfs...")
    mkinitcpio_conf_path = os.path.join(temp_dir_path, "mkinitcpio.conf")
    mkinitcpio_conf = [
        f"MODULES=(fat vfat nls_iso8859_1)",
        f"BINARIES=()",
        f"FILES=()",
        f"HOOKS=(autodetect base udev microcode keyboard keymap numlock block encrypt resume filesystems)",
        f"COMPRESSION=\"cat\"",
        f"COMPRESSION_OPTIONS=()",
    ]
    WriteFile(mkinitcpio_conf_path, "".join([ line + "\n" for line in mkinitcpio_conf ]))
    cpio_path = os.path.join(temp_dir_path, "initramfs.cpio")
    RunCommand(f"mkinitcpio -c \"{mkinitcpio_conf_path}\" -g \"{cpio_path}\" -k \"{kernel_path}\"")

    # Compress initramfs
    print("Compressing initramfs...")
    cpio_zstd_path = cpio_path + ".zst"
    RunCommand(f"zstd --rm \"{cpio_path}\" -o \"{cpio_zstd_path}\"")

    # Generate unified kernel image
    print("Making unified kernel image...")
    crypt_root_uuid = RunCommand(f"blkid -o value -s UUID \"{crypt_root_dev}\"", capture=True)
    # Hiber options
    # resume=UUID={} resume_offset={33699840} hibernate.compressor=lz4 
    cmdline = f"cryptdevice=UUID={crypt_root_uuid}:crypt_root root=/dev/mapper/crypt_root rw"
    kernel_info = RunCommand(f"file \"{kernel_path}\"", capture=True)
    uname = kernel_info[kernel_info.find("version ") + len("version "):]
    uname = uname[:uname.find(" ")]
    ukify_conf_path = os.path.join(temp_dir_path, "ukify.conf")
    ukify_conf = [
        f"[UKI]",
        f"Linux={kernel_path}",
        f"Initrd={cpio_zstd_path}",
        f"OSRelease=EOS",
        f"Uname={uname}",
        f"Cmdline={cmdline}",
    ]
    WriteFile(ukify_conf_path, "".join([ line + "\n" for line in ukify_conf ]))
    efi_path = os.path.join(temp_dir_path, "eos.efi")
    RunCommand(f"ukify -c \"{ukify_conf_path}\" build -o \"{efi_path}\"")
    RunCommand(f"rm \"{cpio_zstd_path}\"")

    # Install uki to boot partition
    RunCommand("rm -rf /boot/*")
    RunCommand("chmod 700 /boot")
    RunCommand("chown +0:+0 /boot")
    RunCommand("mkdir /boot/EFI")
    RunCommand("chmod 700 /boot/EFI")
    RunCommand("chown +0:+0 /boot/EFI")
    RunCommand("mkdir /boot/EFI/BOOT")
    RunCommand("chmod 700 /boot/EFI/BOOT")
    RunCommand("chown +0:+0 /boot/EFI/BOOT")
    RunCommand(f"cp \"{efi_path}\" /boot/EFI/BOOT/BOOTX64.EFI")
    RunCommand("chmod 700 /boot/EFI/BOOT/BOOTX64.EFI")
    RunCommand("chown +0:+0 /boot/EFI/BOOT/BOOTX64.EFI")

    # Setup efi boot entries as needed
    for line in RunCommand("efibootmgr", capture=True).splitlines():
        if not len(line) > 8:
            continue
        if not line.startswith("Boot"):
            continue
        if not line[8:].startswith(" ") and not line[8:].startswith("* "):
            continue
        boot_num = line[4:8]
        if not all([ c in "0123456789" for c in boot_num ]):
            continue
        RunCommand(f"efibootmgr --delete-bootnum --bootnum {boot_num}")
    boot_dev = RunCommand("findmnt --noheadings --raw --output source --target /boot", capture=True)
    boot_disk = os.path.join("/dev", RunCommand(f"lsblk --noheadings --raw --output PKNAME \"{boot_dev}\"", capture=True))
    boot_part = RunCommand(f"lsblk --noheadings --raw --output PARTN \"{boot_dev}\"", capture=True)
    RunCommand(f"efibootmgr --create-only --disk \"{boot_disk}\" --part \"{boot_part}\" --loader \"\\EFI\\BOOT\\BOOTX64.EFI\" --label \"EOS\"")
    for line in RunCommand("efibootmgr", capture=True).splitlines():
        if not len(line) > 8:
            continue
        if not line.startswith("Boot"):
            continue
        if not line[8:].startswith(" ") and not line[8:].startswith("* "):
            continue
        boot_num = line[4:8]
        if not all([ c in "0123456789" for c in boot_num ]):
            continue
        RunCommand(f"efibootmgr --bootorder {boot_num}")
        break
    RunCommand("efibootmgr --timeout 0", check=False)
    RunCommand("efibootmgr --delete-bootnext", check=False)

    # Generate efi certs, keys, and values for efi vars
    eos_uuid = "81702c04-15cc-4573-b5d4-c3a476b635dc"
    openssl_conf = "x509_extensions = noext\n[noext]\nsubjectKeyIdentifier=none"
    openssl_conf_path = os.path.join(temp_dir_path, "openssl.conf")
    WriteFile(openssl_conf_path, openssl_conf)
    keys_dir_path = "/etc/efi_keys"
    if not os.path.exists(keys_dir_path):
        RunCommand(f"mkdir \"{keys_dir_path}\"")
        RunCommand(f"chmod 700 \"{keys_dir_path}\"")
        RunCommand(f"chown +0:+0 \"{keys_dir_path}\"")

    pk_key_path = os.path.join(keys_dir_path, "PK.key")
    if not os.path.exists(pk_key_path):
        RunCommand(f"openssl genrsa -out \"{pk_key_path}\" 4096")
    pk_cert_path = os.path.join(keys_dir_path, "PK.crt")
    if not os.path.exists(pk_cert_path):
        RunCommand(f"openssl req -new -x509 -key \"{pk_key_path}\" -out \"{pk_cert_path}\" -days 3650 -sha256 -subj \"/CN=EOS Autogenerated PK\" -config \"{openssl_conf_path}\"")
    pk_esl_path = os.path.join(keys_dir_path, "PK.esl")
    if not os.path.exists(pk_esl_path):
        RunCommand(f"cert-to-efi-sig-list -g \"{eos_uuid}\" \"{pk_cert_path}\" \"{pk_esl_path}\"")

    kek_key_path = os.path.join(keys_dir_path, "KEK.key")
    if not os.path.exists(kek_key_path):
        RunCommand(f"openssl genrsa -out \"{kek_key_path}\" 4096")
    kek_cert_path = os.path.join(keys_dir_path, "KEK.crt")
    if not os.path.exists(kek_cert_path):
        RunCommand(f"openssl req -new -x509 -key \"{kek_key_path}\" -out \"{kek_cert_path}\" -days 3650 -sha256 -subj \"/CN=EOS Autogenerated KEK\" -config \"{openssl_conf_path}\"")
    kek_esl_path = os.path.join(keys_dir_path, "KEK.esl")
    if not os.path.exists(kek_esl_path):
        RunCommand(f"cert-to-efi-sig-list -g \"{eos_uuid}\" \"{kek_cert_path}\" \"{kek_esl_path}\"")

    db_esl_path = os.path.join(keys_dir_path, "db.esl")
    RunCommand(f"hash-to-efi-sig-list \"{efi_path}\" \"{db_esl_path}\"")
    RunCommand(f"cat \"{oprom_esl_path}\" >> \"{db_esl_path}\"")

    dbx_payload = b"\x26\x16\xc4\xc1\x4c\x50\x92\x40\xac\xa9\x41\xf9\x36\x93\x43\x28\x4c\x00\x00\x00\x1c\x00\x00\x00\x30\x00\x00\x00\x04\x2c\x70\x81\xcc\x15\x73\x45\xb5\xd4\xc3\xa4\x76\xb6\x35\xdc\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01"
    dbx_esl_path = os.path.join(keys_dir_path, "dbx.esl")
    WriteFile(dbx_esl_path, dbx_payload, binary=True)

    # Set efi var values if they are incorrect
    pk_efi_var_path = "/sys/firmware/efi/efivars/PK-8be4df61-93ca-11d2-aa0d-00e098032b8c"
    RunCommand(f"chattr = \"{pk_efi_var_path}\"", check=False)
    pk_actual = b""
    if os.path.exists(pk_efi_var_path):
        pk_actual = ReadFile(pk_efi_var_path, binary=True)[4:]
    pk_expected = ReadFile(pk_esl_path, binary=True)
    if pk_actual != pk_expected:
        if not setup_mode:
            PrintError("PK is incorrect but the device is not in setup mode. Please manually switch.")
            return 1
        pk_auth_path = os.path.join(temp_dir_path, "pk.auth")
        RunCommand(f"sign-efi-sig-list -g \"{eos_uuid}\" -c \"{pk_cert_path}\" -k \"{pk_key_path}\" PK \"{pk_esl_path}\" \"{pk_auth_path}\"")
        RunCommand(f"efi-updatevar -f \"{pk_auth_path}\" PK")

    kek_efi_var_path = "/sys/firmware/efi/efivars/KEK-8be4df61-93ca-11d2-aa0d-00e098032b8c"
    RunCommand(f"chattr = \"{kek_efi_var_path}\"", check=False)
    kek_actual = b""
    if os.path.exists(kek_efi_var_path):
        kek_actual = ReadFile(kek_efi_var_path, binary=True)[4:]
    kek_expected = ReadFile(kek_esl_path, binary=True)
    if kek_actual != kek_expected:
        kek_auth_path = os.path.join(temp_dir_path, "kek.auth")
        RunCommand(f"sign-efi-sig-list -g \"{eos_uuid}\" -c \"{pk_cert_path}\" -k \"{pk_key_path}\" KEK \"{kek_esl_path}\" \"{kek_auth_path}\"")
        RunCommand(f"efi-updatevar -f \"{kek_auth_path}\" KEK")
    
    db_efi_var_path = "/sys/firmware/efi/efivars/db-d719b2cb-3d3a-4596-a3bc-dad00e67656f"
    RunCommand(f"chattr = \"{db_efi_var_path}\"", check=False)
    db_actual = b""
    if os.path.exists(db_efi_var_path):
        db_actual = ReadFile(db_efi_var_path, binary=True)[4:]
    db_expected = ReadFile(db_esl_path, binary=True)
    if db_actual != db_expected:
        db_auth_path = os.path.join(temp_dir_path, "db.auth")
        RunCommand(f"sign-efi-sig-list -g \"{eos_uuid}\" -c \"{kek_cert_path}\" -k \"{kek_key_path}\" db \"{db_esl_path}\" \"{db_auth_path}\"")
        RunCommand(f"efi-updatevar -f \"{db_auth_path}\" db")

    dbx_efi_var_path = "/sys/firmware/efi/efivars/dbx-d719b2cb-3d3a-4596-a3bc-dad00e67656f"
    RunCommand(f"chattr = \"{dbx_efi_var_path}\"", check=False)
    dbx_actual = b""
    if os.path.exists(dbx_efi_var_path):
        dbx_actual = ReadFile(dbx_efi_var_path, binary=True)[4:]
    dbx_expected = ReadFile(dbx_esl_path, binary=True)
    if dbx_actual != dbx_expected:
        dbx_auth_path = os.path.join(temp_dir_path, "dbx.auth")
        RunCommand(f"sign-efi-sig-list -g \"{eos_uuid}\" -c \"{kek_cert_path}\" -k \"{kek_key_path}\" dbx \"{dbx_esl_path}\" \"{dbx_auth_path}\"")
        RunCommand(f"efi-updatevar -f \"{dbx_auth_path}\" dbx")

    # Post Install Cleanup
    RunCommand(f"rm -rf \"{temp_dir_path}\"")
    print("Successfully updated and installed new bootloader!")
    return 0
sys.exit(Main())