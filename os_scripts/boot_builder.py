#!/usr/bin/env python3
import subprocess
import os
import re

# region EOS Script Helpers
def WriteFile(filePath, contents, binary=False):
    filePath = os.path.realpath(os.path.expanduser(filePath))
    os.makedirs(os.path.dirname(filePath), exist_ok=True)
    with open(filePath, "wb" if binary else "w", encoding=(None if binary else "UTF-8")) as file:
        file.write(contents)
def ReadFile(filePath, defaultContents=None, binary=False):
    filePath = os.path.realpath(os.path.expanduser(filePath))
    if not os.path.exists(filePath):
        if defaultContents != None:
            return defaultContents
    with open(filePath, "rb" if binary else "r", encoding=(None if binary else "UTF-8")) as file:
        return file.read()
def RunCommand(command, echo=False, capture=False, input=None, check=True):
    result = subprocess.run(command, capture_output=(not echo), input=input, check=check, shell=True, text=True)
    if capture and not check:
        return (result.stdout + result.stderr).strip(), result.returncode
    elif capture:
        return (result.stdout + result.stderr).strip()
    elif not check:
        return result.returncode
    else:
        return
def PrintWarning(message):
    print(f"\033[93mWarning: {message}\033[0m")
def PrintError(message):
    print(f"\033[91mERROR: {message}\033[0m")
def Install():
    script_path = os.path.realpath(__file__)
    script_name = os.path.splitext(os.path.basename(script_path))[0]
    install_path = f"/usr/bin/{script_name}"
    if script_path == install_path:
        return
    if os.path.isfile(install_path) and os.path.getmtime(script_path) == os.path.getmtime(install_path):
        return
    if os.path.isfile(install_path) and os.path.getmtime(script_path) < os.path.getmtime(install_path):
        PrintWarning(f"Not installing because script in \"{install_path}\" is newer than \"{script_path}\".")
        return
    if os.geteuid() != 0 or os.getegid() != 0:
        print(f"Root is required to install \"{script_path}\" to \"{install_path}\".")
    sudo_commands = [
        f"cp -p \"{script_path}\" \"{install_path}\"",
        f"chmod 755 \"{install_path}\"",
        f"chown +0:+0 \"{install_path}\"",
    ]
    RunCommand(f"sudo sh -c \'{"; ".join(sudo_commands)}\'")
    print(f"Installed \"{script_path}\" to \"{install_path}\".")
    print()
Install()
# endregion

# Initial setup and scanity checks
if RunCommand("findmnt --noheadings --raw --output source --target /boot", check=False) != 0:
    raise Exception("Nothing is mounted on /boot. Did you forget something?")
if RunCommand("findmnt --noheadings --raw --output source --target /sys/firmware/efi/efivars/", check=False) != 0:
    raise Exception("Efivars aren't supported on this system. Maybe you forgot to mount them into a chroot?")
if os.geteuid() != 0 or os.getegid() != 0:
    raise Exception("BootBuilder requires root. Try sudo bootbuilder.")
RunCommand("mkdir -p /tmp/bootbuilder")

# Disable mkinitcpio hooks and add bootbuilder hook
for hookName in os.listdir("/usr/share/libalpm/hooks"):
    if "mkinitcpio" in hookName and not hookName.endswith(".disabled"):
        RunCommand(f"mv \"{os.path.join("/usr/share/libalpm/hooks", hookName)}\" \"{os.path.join("/usr/share/libalpm/hooks", hookName + ".disabled")}\"")
bootbuilderHook = """# This file is auto-generated by bootbuilder.
# Do not modify. All changes will be lost.

[Trigger]
Type = Package
Operation = Install
Operation = Upgrade
Target = linux

[Action]
Description = Running boot builder...
When = PostTransaction
Exec = /usr/bin/bootbuilder"""
WriteFile("/usr/share/libalpm/hooks/bootbuilder.hook", bootbuilderHook)
RunCommand("chmod 644 /usr/share/libalpm/hooks/bootbuilder.hook")

# Locate kernel and modules folders
kernelPath = os.path.join("/usr/lib/modules", os.listdir("/usr/lib/modules")[0], "vmlinuz")

# Generate initramfs
print("Making initramfs...")
mkinitcpioConf = """MODULES=(fat vfat nls_iso8859_1)
BINARIES=()
FILES=()
HOOKS=(autodetect base udev microcode keyboard keymap numlock block encrypt filesystems)
COMPRESSION="cat"
COMPRESSION_OPTIONS=()"""
WriteFile("/tmp/bootbuilder/mkinitcpio.conf", mkinitcpioConf)
RunCommand(f"mkinitcpio -c /tmp/bootbuilder/mkinitcpio.conf -g /tmp/bootbuilder/initramfs.cpio -k \"{kernelPath}\"")

# Compress initramfs
print("Compressing initramfs...")
RunCommand("gzip -n -q -f /tmp/bootbuilder/initramfs.cpio")

# Gather info needed by ukify
print("Making unified kernel image...")
rootDev = RunCommand("findmnt --noheadings --raw --output source --target /", capture=True)
rootUUID = RunCommand(f"blkid -o value -s UUID \"{rootDev}\"", capture=True)
cmdline = f"root=UUID={rootUUID} rw splash"
cryptInfo, cryptStatusCode = RunCommand(f"cryptsetup status \"{rootDev}\"", capture=True, check=False)
if (cryptStatusCode == 0):
    cryptRootDev = cryptInfo[cryptInfo.find("device:") + len("device:"):cryptInfo.find("\n", cryptInfo.find("device:") + len("device:"))].strip()
    cryptRootUUID = RunCommand(f"blkid -o value -s UUID \"{cryptRootDev}\"", capture=True)
    cmdline = f"cryptdevice=UUID={cryptRootUUID}:crypt_root root=/dev/mapper/crypt_root rw splash"
kernelInfo = RunCommand(f"file \"{kernelPath}\"", capture=True)
uname = kernelInfo[kernelInfo.find("version ") + len("version "):kernelInfo.find(" ", kernelInfo.find("version ") + len("version "))]

# Generate unified kernel image
ukifyConf = f"""[UKI]
Linux={kernelPath}
Initrd=/tmp/bootbuilder/initramfs.cpio.gz
OSRelease=BootBuilder OS
Uname={uname}
Cmdline={cmdline}"""
WriteFile("/tmp/bootbuilder/ukify.conf", ukifyConf)
RunCommand(f"ukify -c /tmp/bootbuilder/ukify.conf build -o /tmp/bootbuilder/uki.efi")
RunCommand("rm /tmp/bootbuilder/initramfs.cpio.gz")

# Install uki to boot partition
for path in RunCommand("find /boot", capture=True).splitlines()[::-1]:
    if not path in [ "/boot", "/boot/EFI", "/boot/EFI/BOOT", "/boot/EFI/BOOT/BOOTX64.EFI" ]:
        RunCommand(f"rm -rf \"{path}\"")
RunCommand("mkdir -p /boot/EFI/BOOT/")
RunCommand("cp /tmp/bootbuilder/uki.efi /boot/EFI/BOOT/BOOTX64.EFI")

# Setup efi boot entries as needed
for bootNum in re.findall(r'^Boot(\d{4})', RunCommand("efibootmgr", capture=True), re.MULTILINE):
    RunCommand(f"efibootmgr --delete-bootnum --bootnum {bootNum}")
bootDev = RunCommand("findmnt --noheadings --raw --output source --target /boot", capture=True)
bootDisk = os.path.join("/dev", RunCommand(f"lsblk --noheadings --raw --output PKNAME \"{bootDev}\"", capture=True))
bootPart = RunCommand(f"lsblk --noheadings --raw --output PARTN \"{bootDev}\"", capture=True)
RunCommand(f"efibootmgr --create-only --disk \"{bootDisk}\" --part \"{bootPart}\" --loader \'\\EFI\\BOOT\\BOOTX64.EFI\' --label \"EOS\"")
eosBootNum = re.findall(r'^Boot(\d{4})', RunCommand("efibootmgr", capture=True), re.MULTILINE)[0]
RunCommand(f"efibootmgr --bootorder {eosBootNum}")
RunCommand("efibootmgr --timeout 0", check=False)
RunCommand("efibootmgr --delete-bootnext", check=False)

# Init efi keys if missing
if not os.path.exists("/etc/keys"):
    RunCommand("mkdir -p /etc/keys")
    RunCommand("chmod 755 /etc/keys")

    WriteFile("/tmp/bootbuilder/openssl.conf", "x509_extensions = noext\n[noext]\nsubjectKeyIdentifier=none")
    
    RunCommand("openssl genrsa -out /etc/keys/PK.key 4096")
    RunCommand("openssl req -new -x509 -key /etc/keys/PK.key -out /etc/keys/PK.crt -days 3650 -sha256 -subj \"/CN=EOS Autogenerated PK\" -config /tmp/bootbuilder/openssl.conf")

    RunCommand("openssl genrsa -out /etc/keys/KEK.key 4096")
    RunCommand("openssl req -new -x509 -key /etc/keys/KEK.key -out /etc/keys/KEK.crt -days 3650 -sha256 -subj \"/CN=EOS Autogenerated KEK\" -config /tmp/bootbuilder/openssl.conf")

# Install and setup secure boot keys
eosUUID="81702c04-15cc-4573-b5d4-c3a476b635dc"
setupMode = ReadFile("/sys/firmware/efi/efivars/SetupMode-8be4df61-93ca-11d2-aa0d-00e098032b8c", binary=True)[4:] == b"\x01"
if setupMode:
    print("Device in setup mode. Installing efi keys...")

    RunCommand(f"cert-to-efi-sig-list -g {eosUUID} /etc/keys/PK.crt /tmp/bootbuilder/PK.esl")
    RunCommand(f"sign-efi-sig-list -g {eosUUID} -c /etc/keys/PK.crt -k /etc/keys/PK.key PK /tmp/bootbuilder/PK.esl /tmp/bootbuilder/PK.auth")
    RunCommand("chattr = /sys/firmware/efi/efivars/PK-8be4df61-93ca-11d2-aa0d-00e098032b8c", check=False)
    RunCommand("efi-updatevar -f /tmp/bootbuilder/PK.auth PK")

RunCommand(f"cert-to-efi-sig-list -g {eosUUID} /etc/keys/KEK.crt /tmp/bootbuilder/KEK.esl")
RunCommand(f"sign-efi-sig-list -g {eosUUID} -c /etc/keys/PK.crt -k /etc/keys/PK.key KEK /tmp/bootbuilder/KEK.esl /tmp/bootbuilder/KEK.auth")
RunCommand("chattr = /sys/firmware/efi/efivars/KEK-8be4df61-93ca-11d2-aa0d-00e098032b8c", check=False)
RunCommand("efi-updatevar -f /tmp/bootbuilder/KEK.auth KEK")

RunCommand("hash-to-efi-sig-list /boot/EFI/BOOT/BOOTX64.EFI /tmp/bootbuilder/bootloader.esl")
RunCommand("cat /tmp/bootbuilder/bootloader.esl /home/finlaytheberry/Desktop/vbios.esl > /tmp/bootbuilder/db.esl")
RunCommand(f"sign-efi-sig-list -g {eosUUID} -c /etc/keys/KEK.crt -k /etc/keys/KEK.key db /tmp/bootbuilder/db.esl /tmp/bootbuilder/db.auth")
RunCommand("chattr = /sys/firmware/efi/efivars/db-d719b2cb-3d3a-4596-a3bc-dad00e67656f", check=False)
RunCommand("efi-updatevar -f /tmp/bootbuilder/db.auth db")

WriteFile("/tmp/bootbuilder/dbx.esl", b"\x26\x16\xC4\xC1\x4C\x50\x92\x40\xAC\xA9\x41\xF9\x36\x93\x43\x28\x4C\x00\x00\x00\x00\x00\x00\x00\x30\x00\x00\x00\x04\x2C\x70\x81\xCC\x15\x73\x45\xB5\xD4\xC3\xA4\x76\xB6\x35\xDC\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", binary=True)
RunCommand(f"sign-efi-sig-list -g {eosUUID} -c /etc/keys/KEK.crt -k /etc/keys/KEK.key dbx /tmp/bootbuilder/dbx.esl /tmp/bootbuilder/dbx.auth")
RunCommand("chattr = /sys/firmware/efi/efivars/dbx-d719b2cb-3d3a-4596-a3bc-dad00e67656f", check=False)
RunCommand("efi-updatevar -f /tmp/bootbuilder/dbx.auth dbx")

secureBoot = ReadFile("/sys/firmware/efi/efivars/SecureBoot-8be4df61-93ca-11d2-aa0d-00e098032b8c", binary=True)[4:] == b"\x01"
if not secureBoot:
    print("WARNING: Secure boot is disabled. Many of bootbuilder\'s features won\'t work.")

# Post Install Cleanup
RunCommand("rm -rf /tmp/bootbuilder")
print("Successfully updated and installed new bootloader!")